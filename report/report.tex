\documentclass[acmtog]{acmart}
\usepackage{graphicx}
\usepackage{subfigure}
\usepackage{natbib}
\usepackage{listings}
\usepackage{bm}
\usepackage{amsmath}
\let\liningnums\relax % to solve confliction between ctex and libertine
\usepackage[scheme=plain]{ctex}
\hypersetup{colorlinks}
\geometry{headsep=8ex,bottom=6ex}

\definecolor{blve}{rgb}{0.3372549 , 0.61176471, 0.83921569}
\definecolor{gr33n}{rgb}{0.29019608, 0.7372549, 0.64705882}
\makeatletter
\lst@InstallKeywords k{class}{classstyle}\slshape{classstyle}{}ld
\makeatother
\lstset{language=C++,
	basicstyle=\ttfamily,
	keywordstyle=\color{blve}\ttfamily,
	stringstyle=\color{red}\ttfamily,
	commentstyle=\color{magenta}\ttfamily,
	morecomment=[l][\color{magenta}]{\#},
	classstyle = \bfseries\color{gr33n}, 
	tabsize=2
}
\lstset{basicstyle=\ttfamily\footnotesize}
\linespread{1.2}
\renewcommand{\_}{\underline{\ }}

\title{CS171.01 Final Project:\\ {Massive Rigid-Body Simulation}} 

\author{Name: 丁弘毅\ 王鸿润\ 刘放勋  \\ student ID:\ 2020533039 2020533102 2020533047
\\email: dinghy1|wanghr|liufx@shanghaitech.edu.cn}

\begin{document}
\maketitle

\vspace*{2ex}

\section{Introduction \& Workload}
In this project, we are going to simulate massive rigid body. The workload can be divided mainly into three parts: transformation over time, collision detection and collision response. These parts are finished by 王鸿润, 丁弘毅 and 刘放勋 respectively.\\
The whole pipeline is that in each fixed time interval, we simulate the whole scene for a certain number of times, including updating positions \& velocities and coping with collisions. In each single simulation, we first update the position, velocity and angular velocity of a rigid body according to its acceleration, induced by forces from gravity, collision and friction. Then we check whether there are two of the objects in the scene collide with each other, and if so, we get the collision position, the normal and the signed distance. At last, in the collision response, we tear the two objects apart, and change the velocity \& angular velocity of them according to physical formulas.\\
Here are some useful links:
\begin{itemize}
\item \href{http://games-cn.org/games103/}{GAMES103 Lecture 3,4,9}
\end{itemize}

\section{Brief introduction of the paper's work}
In the time background of the paper, many rigid body physics algorithms were slow, used too much memory, were difficult to implement,
or had other nasty limitations. The author of \textit{Iterative Dynamics with Temporal Coherence} raised three ideas:
\begin{itemize}
	\item Use an approximate contact model that is easy to solve.
	\item Use a sloppy but fast constraint solver.
	\item Clean up the solution over several frames.
\end{itemize}
The author used the following toolkits in his implementation:
\begin{itemize}
	\item Contact point calculator.
	\item Rigid bodies, constraints, and Jacobians.
	\item Gauss-Seidel constraint solver and simple integrator.
	\item Contact cache.
\end{itemize}
The key procedure of his algorithm is shown below: \\
In each time stepping:
\begin{itemize}
	\item 1. Generate contact points.
	\item 2. Initialize contact forces $\lambda$ using a contact cache (generated in the previous step).
	\item 3. Compute the Jacobian $\mathbf{J}$ for non-penetration and friction constraints.
	\item 4. Form an equation for $\lambda$.
	\item 5. Use a Gauss-Seidel solver to refine $\lambda$.
	\item 6. Compute new velocities $v$ and $\omega$ using $\lambda$.
	\item 7. Compute new positions $x$ and $q$ from $v$ and $\omega$.
	\item 8. Store $\lambda$ in the contact cache.
	\item 9. Go to step 1.
\end{itemize}
His algorithm can be summarized as:
\begin{itemize}
	\item Compute the collision point.
	\item Apply external force (such as gravity).
	\item Apply impulse.
	\item Update the positions.
	\item Go back to loop.
\end{itemize}

\section{Implementation Details}

\subsection{Transform over time}
For each object, it has its own velocity and angular velocity, acceleration and angular acceleration.In simulation,we update the status of every object ,compute the position and normal.\\
For velocity, 
\begin{equation*}
velocity += acceleration\times Ddelta t,\quad position += v\times\Delta t.
\end{equation*}
For angular velocity, 
\begin{equation*}
\omega += angular acceleration \times\Delta t 
\end{equation*} and the Quaternion of rotation is $q = q + \{0,\frac{\delta t}{2}\omega\}\times q$ and normalize the Quaternion.\\
Then apply the transform function to change positon.

\subsection{Collision Detection}
To judge whether two rigid-body meshes $A$ and $B$ collide with each other, the universal idea is to traverse each vertex $a$ of $A$, if there is some $a$ collides with $B$, then there is a collision and we need to respond to it. If there are multiple $a$'s colliding with $B$, we can just view it as a collision at the average position of collision with average normal and average distance. But actually if time slice is small enough, there will only be one point colliding with some other objects each time.\\
As to how to know whether a point $a$ collides with $B$, we only need to know the $sdf$ (signed distance function) of $B$ on point $a$. It is defined as the maximum signed distance from any point of $B$ to $a$. For uniseral triangle mesh, we need to traverse each triangle, and calculate the distance from $a$ to the plane of triangle, and finally take the maximum value, which turns out to be the $sdf$ of $B$ on $a$.\\
However, the universal way might be costy and slow, which wastes plenty of time on non-intersect objects and verteces. First, instead of scanning every pair of objects, we can skip those pairs that are too far away with each other, either by Spatial Hashing or BVH (Bounding Volumn Hierarchies).\\
Second, we don't need to calculate the sdf of $B$ on all the vertices $a$. Since most of those vertices won't collide with $B$, we can skip those vertices with some data structures. Because the structure of a rigid-body is stable, we can construct a BVH for each object, then skip the vertices whose AABB does not intersect with the AABB of $B$.\\
At last, if objects are special geometries, we can make special optimizations for them. For example, for spheres, if we want to know the $sdf$ of sphere $O$ on $P$, we only need to calculate $|OP|-r$. Similarly, if we want to know whether two spheres $O_1$ and $O_2$ intersects, we only need to judge whether $|O_1O_2|-r1-r_2>0$. This is of great improvement than the uniseral traverse of vertices and mesh triangles.
The data sent from detector to responder is defined as follow:
\begin{lstlisting}
struct Interaction{
	Float dis;      // signed distance
	Vec3 position;  // position of vertex a that collides
	Vec3 normal;    // the normal of object B's colliding plane
};
\end{lstlisting}

\subsection{Collision Response}
First, we implement a simple form of collision response. If the velocity $v$ of current object is pointing into the collided object,
we check the dot product of $\mathbf{v}$ and normal $\mathbf{n}$ of the collision point: $t = \mathbf{v}\cdot\mathbf{n}$.
If $t<0$, we reverse both $\mathbf{v}$ and $t$. Then we use the following way to update the velocity:
$$\mathbf{v} \leftarrow 2 t \mathbf{n} - \mathbf{v}$$
To make the resting contact stable, we judge that when the velocity is too small, stop updating position of the object. \\

Then we look into a more advanced collision response. We choose the impulse method. Its basic idea is to use the velocity change of
the collision point to get the impulse applied on the object, then use the impulse to update the velocity of the whole object.
We implement the impulse method in the following four steps. \\

\textbf{Step 1: Judge whether the update is needed} \\
In the previous collision detection phase, we have detected the collision point. Then we need to judge whether the velocity $\mathbf{v}_i$ of
the collision point is pointing to the inside of the collided object. If not, then we don't need to do the update as the velocity
is already outward. \\

\textbf{Step 2: Compute the new velocity $\mathbf{v}_i^{new}$ of the collision point $i$} \\
Denote the normal of the collision point to be $\mathbf{N}$, pointing to the outside of the collided object. First we decompose
the old velocity $\mathbf{v}_i$ into normal velocity $\mathbf{v}_{\mathbf{N},i}$ and tangential velocity $\mathbf{v}_{\mathbf{T},i}$:
$$\mathbf{v}_{\mathbf{N},i} \leftarrow (\mathbf{v}_i\cdot \mathbf{N})\mathbf{N}$$
$$\mathbf{v}_{\mathbf{T},i} \leftarrow \mathbf{v}_i - \mathbf{v}_{\mathbf{T},i}$$
We introduce two coefficients $\mu_\mathbf{N},\mu_\mathbf{T} \in (0,1)$ to update the two decomposed velocities separately.
We wish our object to go away from the collided object, so the normal velocity should be reversed, and by conservation of energy,
the out normal velocity should be no larger than the in normal velocity, and may decay in energy.
So we update the normal velocity by the following:
$$\mathbf{v}_{\mathbf{N},i}^{new} \leftarrow -\mu_\mathbf{N} \mathbf{v}_{\mathbf{N},i}$$
Due to the existence of friction, the tangential velocity should also decay in energy.
We update the tangential velocity by the following:
$$\mathbf{v}_{\mathbf{T},i}^{new} \leftarrow a \mathbf{v}_{\mathbf{T},i}$$
The computation of $a$ is needed. By Amontons-Coulomb Friction Laws, we know
$$F_f \leq \mu_\mathbf{T} F_N,$$
where $\mu_\mathbf{T}$ is the friction coefficient, then
$$||\mathbf{v}_{\mathbf{T},i}^{new} - \mathbf{v}_{\mathbf{T},i}|| \leq \mu_\mathbf{T} ||\mathbf{v}_{\mathbf{N},i}^{new} - \mathbf{v}_{\mathbf{N},i}||$$
$$(1-a)||\mathbf{v}_{\mathbf{T},i}|| \leq \mu_\mathbf{T} (1+\mu_\mathbf{N})||\mathbf{v}_{\mathbf{N},i}||$$
$$a \leq 1 - \frac{\mu_\mathbf{T} (1+\mu_\mathbf{N})||\mathbf{v}_{\mathbf{N},i}||}{||\mathbf{v}_{\mathbf{T},i}||}$$
In our simulation, we take the equals sign. $a$ should also satisfies $a \geq 0$, so the computation of $a$ is:
$$a \leftarrow \max(1 - \frac{\mu_\mathbf{T} (1+\mu_\mathbf{N})||\mathbf{v}_{\mathbf{N},i}||}{||\mathbf{v}_{\mathbf{T},i}||}, 0)$$
Now we have the normal and tangential velocity of the new velocity, then the new velocity is:
$$\mathbf{v}_i^{new} \leftarrow \mathbf{v}_{\mathbf{N},i} + \mathbf{v}_{\mathbf{T},i}$$

\textbf{Step 3: Compute the impulse $\mathbf{j}$} \\
Assume the impulse is applied on the collision point, it will change the velocity and the angular velocity of the object:
$$\mathbf{v}^{new} \leftarrow \mathbf{v} + \frac{1}{M}\mathbf{j}$$
$$\mathbf{\omega}^{new} \leftarrow \mathbf{\omega} + \mathbf{I}^{-1}(\mathbf{R}\mathbf{r}_i\times\mathbf{j})$$
where $\mathbf{I}$ is the inertia, $\mathbf{R}$ is the rotation matrix and $\mathbf{r}$ is the local coordinate of the collision point.
$(\mathbf{R}\mathbf{r}_i\times\mathbf{j})$ is the torque induced by $\mathbf{j}$. \\
Then we take the $\mathbf{v}^{new},\mathbf{\omega}^{new}$ into following equation:
$$
\begin{aligned}
	\mathbf{v}_i^{new}
	&= \mathbf{v}^{new} + \mathbf{\omega}^{new} \times \mathbf{R}\mathbf{r}_i \\
	&= \mathbf{v} + \frac{1}{M}\mathbf{j} + (\mathbf{\omega} + \mathbf{I}^{-1}(\mathbf{R}\mathbf{r}_i\times\mathbf{j})) \times \mathbf{R}\mathbf{r}_i \\
	&= \mathbf{v}_i + \frac{1}{M}\mathbf{j} + (\mathbf{I}^{-1}(\mathbf{R}\mathbf{r}_i\times\mathbf{j})) \times \mathbf{R}\mathbf{r}_i \\
	&= \mathbf{v}_i + \frac{1}{M}\mathbf{j} - (\mathbf{R}\mathbf{r}_i) \times (\mathbf{I}^{-1}(\mathbf{R}\mathbf{r}_i\times\mathbf{j}))
\end{aligned}
$$
We convert the cross product $mathbf{r}\times$ into a matrix product $mathbf{r}*$ in the way shown in Fig.1.
\begin{figure}
\centering
\includegraphics[height=1.5cm,width=8cm]{cross_matrix.png}
\caption{convertion of cross product to matrix product}
\end{figure}
Then we can convert the above equation to the following:
$$\mathbf{v}_i^{new} = \mathbf{v}_i + \frac{1}{M}\mathbf{j} - (\mathbf{R}\mathbf{r}_i)* \mathbf{I}^{-1} (\mathbf{R}\mathbf{r}_i)* \mathbf{j}$$
So we can get:
$$\mathbf{v}_i^{new} - \mathbf{v}_i = \mathbf{K} \mathbf{j}$$
where
$$\mathbf{K} \leftarrow \frac{1}{M}\mathbf{1} - (\mathbf{R}\mathbf{r}_i)* \mathbf{I}^{-1} (\mathbf{R}\mathbf{r}_i)*$$
Now we can get the impulse $\mathbf{j}$:
$$\mathbf{j} \leftarrow \mathbf{K}^{-1} (\mathbf{v}_i^{new} - \mathbf{v}_i)$$

\textbf{Step 4: Update $\mathbf{v}$ and $\mathbf{\omega}$} \\
Lastly, we need to use the impulse to update $\mathbf{v}$ and $\mathbf{\omega}$:
$$\mathbf{v} \leftarrow \mathbf{v} + \frac{1}{M}\mathbf{j}$$
$$\mathbf{\omega} \leftarrow \mathbf{\omega} + \mathbf{I}^{-1}(\mathbf{R}\mathbf{r}_i\times\mathbf{j})$$

Now the collision response using impulse method has finished. \\

Disappointingly, although we do the impulse method implementation following the above procedure, the simulaiton could not work well.
We guess that it may be due to some difference on settings. At last, we use the first implementation to deal with collision response,
but still retain the impulse method implementation in our code.

\section{Results}

\end{document}
